//node
import crypto from "crypto";
import * as path from "path";

// Externals
import { createLightship } from 'lightship';
import { Command, Option } from "commander";
import express from "express";
import cookieParser from "cookie-parser";
import logger from "morgan";
import { auth } from "express-openid-connect";

// Internals
import { version } from '../package.json';
import { errorHandler } from "./middlewares/errorHandler";


/**
 * Sety up CLI options & config
 */
const program = new Command();
program
    .version(version)
    .addOption(
        new Option('-p, --port <port>', 'Port to run the srevice on')
        .default(3000)
        .env('PORT')
        .makeOptionMandatory())
    .addOption(
        new Option('--probes <port>', 'Port to serve /live, /health and /ready probes on.')
        .default(9090)
        .env('PROBES_PORT'))
    .addOption(
        new Option('--cookie-secret <secret>', 'Cookie secret to use in auth. Will be autogenerated if not provided')
        .default(Buffer.from(crypto.randomBytes(64)).toString('base64'))
        .env('COOKIE_SECRET'))
    .addOption(
        new Option('--callback-path <path>', 'The callback path to receive idp responses on')
        .default('/callback')
        .env('CALLBACK_PATH')
        .makeOptionMandatory())
    .addOption(
        new Option('--oidc-client-id <id>', 'The OIDC client id.')
        .env('OIDC_CLIENT_ID')
        .makeOptionMandatory())
    .addOption(
        new Option('--oidc-client-secret <secret>', 'The OIDC client secret.')
        .env('OIDC_CLIENT_SECRET')
        .makeOptionMandatory())
    .addOption(
        new Option('--oidc-base-url <baseUrl>', 'The base URL for the auth process (eg: https://auth.example.com).')
        .env('OIDC_BASE_URL')
        .makeOptionMandatory())
    .addOption(
        new Option('--oidc-issuer-url <issuerUrl>', 'The OIDC issuer url (eg: https://catalystgamma.eu.auth0.com).')
        .env('OIDC_ISSUER_URL')
        .makeOptionMandatory())
    .showHelpAfterError();

program.parse(process.argv);
const config = program.opts();

/**
 * Set up watcher that provides /live, /health and /ready endpoints
 */
const lightship = createLightship({
    port: config.probes,
    
});



/**
 * Create express app
 */
export const app = express();

app.set("views", path.join(__dirname, "../views"));
app.set("view engine", "pug");

app.use(express.static(path.join(__dirname, "../public")));
app.use(logger("dev"));
app.use(cookieParser(config.COOKIE_SECRET));
app.use(auth({
    authRequired: true,
    auth0Logout: true,
    idpLogout: true,
    issuerBaseURL: config.OIDC_ISSUER_BASE_URL,
    baseURL: config.OIDC_BASE_URL,
    clientID: config.OIDC_CLIENT_ID,
    secret: config.COOKIE_SECRET,
}));

app.all("*", async (req, res) => {
    // Save userinfo in a cookie
    const userInfo = await req.oidc.fetchUserInfo();
    res.cookie("userinfo", Buffer.from(JSON.stringify(userInfo)).toString('base64'), { signed:true });
    // We're good to go.
    res.status(200).send('OK');

});

app.use(errorHandler);



/**
 * Run server and handle errors
 */

const server = app.listen(config.port, () => {
    const addr = server.address();
    console.log(`Listening on ${addr}`);
    lightship.signalReady();
});

server.on("error", (error: NodeJS.ErrnoException) => {
    lightship.shutdown();

    if (error.syscall !== "listen") {
        throw error;
    }

    // handle specific listen errors with friendly messages
    switch (error.code) {
        case "EACCES":
            console.error(`${config.port} requires elevated privileges`);
            process.exit(1);
            break;
        case "EADDRINUSE":
            console.error(`${config.port} is already in use`);
            process.exit(1);
            break;
        default:
            throw error;
    }
});

// Taken care of by lightship
// process.on('SIGTERM', () => {
//     console.error('SIGTERM signal received: closing HTTP server');
//     server.close(() => {
//         lightship.shutdown();
//         console.error('HTTP server closed');
//     });
// });

// export default server;
